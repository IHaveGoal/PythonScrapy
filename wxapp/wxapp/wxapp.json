{"title": "微信小程序开发中的代码片段总结 ", "author": "Rolan", "time": "2019-3-22 00:34", "mh_content": " \n                     \n                    经过一段时间的微信小程序开发，总结了一些代码片段，主要是以下几个方面：小程序（授权、网络、录音、图像）mpvue（分包、全局变量、svg组件、组件class绑定）小程序授权逻辑初次请求 -> 请求用户授权 -> 同意授权(-> 不同意授权 -> 结束) -> 使用对应功能二次请求 -> 跳转小程序设置页面modal -> 设置页面 -> 开启scope -> 使用对应功能const checkPermission = scope =>\r\n  new Promise((resolve, reject) => {\r\n    wx.getSetting({\r\n      success: res => {\r\n        // 是否存在认证配置\r\n        let hasAuthorized = res.authSetting.hasOwnProperty(scope)\r\n        if (hasAuthorized) {\r\n          // 已授权\r\n          if (res.authSetting[scope]) {\r\n            resolve('已授权')\r\n            return\r\n          }\r\n          // 未授权，提示进入小程序设置页面，wx限制:需要主动点击才能执行openSetting()，因此使用modal\r\n          wx.showModal({\r\n            title: '没有权限',\r\n            content: '体验该功能需要您授权功能权限，现在前往设置开启',\r\n            success: res => {\r\n              if (res.confirm) {\r\n                reject('设置页面')\r\n                wx.openSetting()\r\n              } else if (res.cancel) {\r\n                reject('不进入设置')\r\n              }\r\n            }\r\n          })\r\n        }\r\n      },\r\n      fail: err => { reject(err.errMsg) }\r\n    })\r\n  })网络微信小程序不同环境下网络请求的不同之处：校验合法域名、web-view（业务域名）、TLS 版本以及 HTTPS 证书\r\n网络请求与拦截器可以使用 fly.js 作为小程序的网络请求库，在使用拦截器等功能时也较为方便。小程序中一个特殊的地方是: content-type 为 multipart/formdata 类型的POST请求不能通过自定义请求的方式发出，需要使用小程序的 wx.uploadFile 方法，可以如下简单封装下：const formDataRequest = (url, filePath, params = {}) =>\r\n  new Promise((resolve, reject) => {\r\n    let token = wx.getStorageSync(\"token\")\r\n    wx.uploadFile({\r\n      url,\r\n      filePath,\r\n      name: \"file\",\r\n      header: { token },\r\n      formData: params,\r\n      success: async res => {\r\n        // 一些对响应数据的处理...\r\n        resolve(res.data)\r\n      },\r\n      fail: err => {\r\n        reject(err)\r\n      }\r\n    });\r\n  });判断是否在线使用 getNetworkType 方法即可export const isOnline = () =>\r\n  new Promise((resolve, reject) => {\r\n    wx.getNetworkType({\r\n      success(res) {\r\n        const networkType = res.networkType\r\n        resolve(networkType !== 'none')\r\n      },\r\n      failed(res) {\r\n        reject(res)\r\n      }\r\n    })\r\n  })录音处理主要是录音时的API检测、状态控制与事件监听器的处理。// 1. 检测录音管理器是否可用\r\nif (wx.getRecorderManager) {\r\n  this.recorder = wx.getRecorderManager()\r\n  this.addRecorderListener()\r\n} else {\r\n  wx.showModal({\r\n    title: '提示',\r\n    showCancel: false,\r\n    content:\r\n      '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。'\r\n  })\r\n}\r\n// 2. 录音前检测scope.record授权情况\r\nasync startRecordHandle() {\r\n  if (!this.recorder) return\r\n  try { await this.checkPermission('scope.record') }  \r\n  catch (err) { return }\r\n  this.recorder.start(this.audioOption)\r\n},\r\n// 3. 添加事件监听器\r\naddRecorderListener() {\r\n  if (!this.recorder) return\r\n  this.recorder.onStart(() => {\r\n    ...\r\n    this.recording = true\r\n  })\r\n  this.recorder.onStop(path => {\r\n    ...\r\n    this.recording = false\r\n    this.audioPath = path.tempFilePath\r\n  })\r\n}若需实现长按录音的场景，可以结合 lonepress 事件与 setTimeout 来实现。<template>\r\n  <g-button type=\"primary\"\r\n    ...\r\n    @long-press=\"longPressHandle\"\r\n  />\r\n</template>\r\n<script>\r\nexport default {\r\n  methods: {\r\n    longPressHandle() {\r\n      // longpress事件会在350ms后出发\r\n      this.canRecordStart = true\r\n    },\r\n    touchStartHandle() {\r\n      this.canRecordStart = true\r\n      let delay = 400 // 设置400ms延迟\r\n      setTimeout(() => {\r\n        if (this.canRecordStart) {\r\n          this.startRecordHandle()\r\n        }\r\n      }, delay)\r\n    },\r\n    touchEndHandle() {\r\n      if (!this.canRecordStart) return\r\n      this.canRecordStart = false\r\n      this.stopRecordHandle()\r\n    },\r\n  }\r\n}\r\n</script>图像处理获取图片信息wx.getImageInfo不管是CDN的图片还是本地选择的图片都需要先使用 getImageInfo 获取图片的基本信息getImageInfo(img) {\r\n  return new Promise((resolve, reject) => {\r\n    wx.getImageInfo({\r\n      src: img,\r\n      success: res => { resolve(res) },\r\n      fail: () => { reject('获取图片信息失败') }\r\n    })\r\n  })\r\n}选择图片wx.chooseImage让用户选择本地相册中或拍摄的图片，以选择单张图片为例：const MB = 1024 * 1024\r\nchooseSingleImage() {\r\n  return new Promise((resolve, reject) => {\r\n    wx.chooseImage({\r\n      count: 1, // 默认9，为1获取单张图片\r\n      sizeType: ['original', 'compressed'], // 指定是原图还是压缩图，默认二者都有\r\n      sourceType: ['album', 'camera'], // 指定来源是相册还是相机，默认二者都有\r\n      success: res => {\r\n        let file = res.tempFiles[0]\r\n        // 可以对所选图片尺寸或其他属性做一些限制\r\n        // let { size } = file\r\n        // if (size > 20 * MB) { reject('图片大小应小于20MB') }\r\n        resolve(file)\r\n      },\r\n      fail: () => { reject('图片选取失败') }\r\n    })\r\n  })\r\n}读取图片wx.getFileSystemManager()使用小程序的FS相关API读取文件内容readFileInBase64(filePath) {\r\n  return new Promise((resolve, reject) => {\r\n    if (wx.getFileSystemManager) {\r\n      // 以base64编码读取图片\r\n      wx.getFileSystemManager().readFile({\r\n        filePath: filePath,\r\n        encoding: 'base64',\r\n        success: res => { resolve(res) },\r\n        file: () => { reject('读取文件失败') }\r\n      })\r\n    } else {\r\n      // 兼容处理，若不支持则提示更新\r\n      wx.showModal({\r\n        title: '提示',\r\n        showCancel: false,\r\n        content:\r\n          '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。'\r\n      })\r\n    }\r\n  })\r\n}Canvas绘制图像小程序中使用CanvasContext API与H5的形式基本相同。需要注意的是，在小程序中绘制canvas时尺寸的单位是 px ，而不是响应式的 rpx 。需要注意的是从基础库 1.9.90 开始 CanvasContext 的API变化了很多，在使用时需要注意兼容性，比如下面两个函数：export const drawPoint = (ctx, x, y) => {\r\n  let pointColor = '#2ba5ff'\r\n  ctx.beginPath()\r\n  ctx.arc(x, y, 1, 0, Math.PI * 2, true)\r\n  ctx.closePath()\r\n  // 兼容画布填充色方法\r\n  if (ctx.fillStyle) {\r\n    // 1.9.90+\r\n    ctx.fillStyle = pointColor\r\n  } else {\r\n    ctx.setFillStyle(pointColor)\r\n  }\r\n  ctx.fill()\r\n}\r\n\r\nexport const drawRect = (ctx, x, y, width, height) => {\r\n  let marginColor = '#ff0000'\r\n  // 兼容笔触色彩方法\r\n  if (ctx.strokeStyle) {\r\n    // 1.9.90+\r\n    ctx.strokeStyle = marginColor\r\n  } else {\r\n    ctx.setStrokeStyle(marginColor)\r\n  }\r\n  ctx.lineWidth = 1\r\n  ctx.strokeRect(x, y, width, height)\r\n}mpvue分包及分包预加载mpvue-loader: ^1.1.2\r\n直接在 app.json 中配置 subPackages 即可:{\r\n  ...\r\n  \"subPackages\": [\r\n    {\r\n      \"root\": \"pages/module-bob/\",\r\n      \"pages\": [\"subpage-a/main\", \"subpage-b/main\", \"subpage-c/main\"]\r\n    },\r\n    {\r\n      \"root\": \"pages/module-alice/\",\r\n      \"pages\": [\"subpage-d/main\", \"subpage-e/main\", \"subpage-f/main\"]\r\n    }\r\n  ],\r\n  \"preloadRule\": {\r\n    \"pages/index/main\": {\r\n      \"network\": \"wifi\",\r\n      \"packages\": [\"pages/module-bob\"]\r\n    }\r\n  }\r\n  ...\r\n}其中 preloadRule 为预加载配置，上面的设置意为进入index页面时当为wifi网络时预加载module-bob子包。https://segmentfault.com/a/1190000017064732使用globalData全局变量在小程序中将自带的[ globalData ]()挂载到vue的原型方法上。在src中的 main.js 最后添加如下代码:import Vue from 'vue'\r\nimport App from './App'\r\n...\r\nconst app = new Vue(App)\r\napp.$mount()\r\nVue.prototype.$globalData = getApp().globalData // 添加该行然后就可以在其他页面使用该命令操作全局变量了// page A\r\nthis.$globalData.userInfo = {name: 'yrq110'}\r\n// page B\r\nconsole.log(this.$globalData.userInfo)\r\n// page C\r\nthis.$globalData.userInfo.name: 'yrq110'注意，在子页面中使用globalData时，将变量赋值的操作放在data中是无效的，如下:export default {\r\n  data() {\r\n    // 无效\r\n    // isIPX: this.$globalData.isIPX\r\n  },\r\n  computed: {\r\n    isIPX() {\r\n      // 有效\r\n      return this.$globalData.isIPX\r\n    }\r\n  },\r\n}SVG图标组件的默认尺寸与预设尺寸在图标组件中加载svg时使用父标签上的尺寸作为默认尺寸，并在传入特定props参数时使用预设尺寸。业务中碰到了这个问题，使用如下的方法进行了解决：在image组件的load事件处理器中将加载的原始尺寸绑定到style上。实现了： 1. 默认使用svg标签自带尺寸 2. 当传入size属性则使用预设尺寸<template>\r\n  <image\r\n    ...\r\n    @load=\"loadHandle\"\r\n    :style=\"{ width: !size ? iconWidth + 'rpx' : '100%', height: !size ? iconHeight + 'rpx' : '100%'}\"\r\n    ...\r\n  />\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  ...\r\n  data() {\r\n    return {\r\n      iconWidth: 0,\r\n      iconHeight: 0,\r\n      loaded: false // 是否加载完毕\r\n    }\r\n  },\r\n  props: {\r\n    ...\r\n    size: String\r\n  },\r\n  computed: {\r\n    ...\r\n    getSizeClass() {\r\n      let { size } = this\r\n      return size || ''\r\n    },\r\n    setSizeStyle() {\r\n      if (!this.loaded || this.size) return {}\r\n      return {\r\n        width: this.iconWidth + 'rpx',\r\n        height: this.iconHeight + 'rpx'\r\n      }\r\n    }\r\n  },\r\n  methods: {\r\n    loadHandle(e) {\r\n      this.loaded = true\r\n      // 使用加载后的默认尺寸\r\n      const { detail } = e.mp\r\n      this.iconWidth = detail.width * 2\r\n      this.iconHeight = detail.height * 2\r\n    }\r\n  }\r\n  ...\r\n}\r\n</script>解决无法在组件上绑定class的trick将keyword作为prop属性传入组件并通过Computed属性绑定到class上，这样在外部引用时就可以根据keyword设置自定义的样式了。组件中的关键代码如下：<template>\r\n  <div :class=\"customClass\">\r\n    <slot></slot>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  ...\r\n  props: {\r\n    type: String,\r\n    ...\r\n  },\r\n  computed: {\r\n    customClass() {\r\n      let type = this.type || ''\r\n      return type\r\n    }\r\n  }\r\n  ...\r\n}\r\n</script>在外部引用时就可以使用自定义class来在外部使用样式了:<template>\r\n  ...\r\n  <g-button type=\"custom-button\"></g-button>\r\n  ...\r\n</template>\r\n...\r\n<style lang=\"scss\">\r\n...\r\n.custom-button {\r\n  .text {\r\n    margin-left: 10px;\r\n  }\r\n...\r\n}\r\n</style> "}
